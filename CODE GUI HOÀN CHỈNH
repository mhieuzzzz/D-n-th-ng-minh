import tkinter as tk
from tkinter import scrolledtext, messagebox
import serial
import serial.tools.list_ports
import threading
import queue
import time

# ---- C·∫•u h√¨nh ----
BAUDRATE = 9600
READ_TIMEOUT = 0.1

# ---- Theme Colors ----
COLORS = {
    'bg': '#0f172a',
    'card': '#1e293b',
    'accent': '#3b82f6',
    'success': '#10b981',
    'warning': '#f59e0b',
    'danger': '#ef4444',
    'text': '#f1f5f9',
    'text_dim': '#94a3b8',
    'border': '#334155',
}

# ---- H√†m t√¨m COM ----
def list_serial_ports():
    ports = [p.device for p in serial.tools.list_ports.comports()]
    return ports if ports else ["No ports found"]

# ---- Thread ƒë·ªçc Serial ----
class SerialReader(threading.Thread):
    def __init__(self, ser, q, stop_event):
        super().__init__(daemon=True)
        self.ser = ser
        self.q = q
        self.stop_event = stop_event

    def run(self):
        buffer = ""
        while not self.stop_event.is_set():
            try:
                if self.ser and self.ser.in_waiting:
                    data = self.ser.read(self.ser.in_waiting).decode(errors='ignore')
                    buffer += data
                    while '\n' in buffer:
                        line, buffer = buffer.split('\n', 1)
                        self.q.put(line.strip())
                else:
                    time.sleep(0.05)
            except Exception as e:
                self.q.put(f"__ERROR__:{e}")
                time.sleep(0.5)

# ---- Modern Button ----
class ModernButton(tk.Canvas):
    def __init__(self, parent, text, command, bg_color=COLORS['accent'], **kwargs):
        super().__init__(parent, highlightthickness=0, bg=COLORS['card'], **kwargs)
        self.text = text
        self.command = command
        self.bg_color = bg_color
        self.hover_color = self.lighten_color(bg_color)
        self.is_hovered = False
        self.animation_id = None
        self.current_color = bg_color

        self.bind('<Enter>', self.on_enter)
        self.bind('<Leave>', self.on_leave)
        self.bind('<Button-1>', self.on_click)

        self.draw()

    def lighten_color(self, hex_color):
        r, g, b = int(hex_color[1:3], 16), int(hex_color[3:5], 16), int(hex_color[5:7], 16)
        r, g, b = min(255, r + 30), min(255, g + 30), min(255, b + 30)
        return f'#{r:02x}{g:02x}{b:02x}'

    def draw(self):
        self.delete('all')
        width, height = self.winfo_reqwidth() or 120, self.winfo_reqheight() or 40
        self.config(width=width, height=height)

        r = 8
        self.create_rounded_rect(2, 2, width - 2, height - 2, r, fill=self.current_color, outline='')
        self.create_text(width / 2, height / 2, text=self.text,
                         fill=COLORS['text'], font=('Segoe UI', 10, 'bold'))

    def create_rounded_rect(self, x1, y1, x2, y2, r, **kwargs):
        points = [x1 + r, y1, x1 + r, y1, x2 - r, y1, x2 - r, y1, x2, y1, x2, y1 + r, x2, y1 + r,
                  x2, y2 - r, x2, y2 - r, x2, y2, x2 - r, y2, x2 - r, y2, x1 + r, y2, x1 + r, y2,
                  x1, y2, x1, y2 - r, x1, y2 - r, x1, y1 + r, x1, y1 + r, x1, y1]
        return self.create_polygon(points, smooth=True, **kwargs)

    def animate_color(self, target_color, steps=10):
        if self.animation_id:
            self.after_cancel(self.animation_id)

        start_r = int(self.current_color[1:3], 16)
        start_g = int(self.current_color[3:5], 16)
        start_b = int(self.current_color[5:7], 16)

        end_r = int(target_color[1:3], 16)
        end_g = int(target_color[3:5], 16)
        end_b = int(target_color[5:7], 16)

        step_r = (end_r - start_r) / steps
        step_g = (end_g - start_g) / steps
        step_b = (end_b - start_b) / steps

        def step_animation(current_step=0):
            if current_step < steps:
                new_r = int(start_r + step_r * current_step)
                new_g = int(start_g + step_g * current_step)
                new_b = int(start_b + step_b * current_step)
                self.current_color = f'#{new_r:02x}{new_g:02x}{new_b:02x}'
                self.draw()
                self.animation_id = self.after(15, lambda: step_animation(current_step + 1))
            else:
                self.current_color = target_color
                self.draw()

        step_animation()

    def on_enter(self, e):
        self.is_hovered = True
        self.animate_color(self.hover_color)
        self.config(cursor='hand2')

    def on_leave(self, e):
        self.is_hovered = False
        self.animate_color(self.bg_color)
        self.config(cursor='')

    def on_click(self, e):
        if self.command:
            self.scale('all', self.winfo_width() / 2, self.winfo_height() / 2, 0.95, 0.95)
            self.after(100, lambda: self.scale('all', self.winfo_width() / 2, self.winfo_height() / 2, 1 / 0.95, 1 / 0.95))
            self.command()

# ---- Status Card ----
class StatusCard(tk.Frame):
    def __init__(self, parent, title, icon, **kwargs):
        super().__init__(parent, bg=COLORS['card'], **kwargs)
        self.title = title
        self.icon = icon

        self.icon_lbl = tk.Label(self, text=icon, font=('Segoe UI', 24),
                                 fg=COLORS['accent'], bg=COLORS['card'])
        self.icon_lbl.pack(pady=(15, 5))

        tk.Label(self, text=title, font=('Segoe UI', 10),
                 fg=COLORS['text_dim'], bg=COLORS['card']).pack()

        self.value_lbl = tk.Label(self, text="--", font=('Segoe UI', 20, 'bold'),
                                  fg=COLORS['text'], bg=COLORS['card'])
        self.value_lbl.pack(pady=(5, 15))

    def update_value(self, value, color=COLORS['text']):
        self.value_lbl.config(text=value, fg=color)
        self.animate_pulse()

    def animate_pulse(self):
        original_font = self.value_lbl.cget('font')
        self.value_lbl.config(font=('Segoe UI', 22, 'bold'))
        self.after(100, lambda: self.value_lbl.config(font=original_font))

# ---- GUI ch√≠nh ----
class SmartParkingGUI:
    def __init__(self, root):
        self.root = root
        root.title("Smart Parking System")
        root.configure(bg=COLORS['bg'])

        # Header
        header = tk.Frame(root, bg=COLORS['card'], height=70)
        header.pack(fill='x', padx=10, pady=(10, 0))
        header.pack_propagate(False)

        tk.Label(header, text="üÖøÔ∏è", font=('Segoe UI', 32),
                 bg=COLORS['card'], fg=COLORS['accent']).pack(side='left', padx=(20, 10))

        title_frame = tk.Frame(header, bg=COLORS['card'])
        title_frame.pack(side='left', fill='y')
        tk.Label(title_frame, text="Smart Parking", font=('Segoe UI', 18, 'bold'),
                 bg=COLORS['card'], fg=COLORS['text']).pack(anchor='w')
        tk.Label(title_frame, text="Management System", font=('Segoe UI', 9),
                 bg=COLORS['card'], fg=COLORS['text_dim']).pack(anchor='w')

        # Connection Frame
        conn_frame = tk.Frame(root, bg=COLORS['card'])
        conn_frame.pack(fill='x', padx=10, pady=10)

        inner_conn = tk.Frame(conn_frame, bg=COLORS['card'])
        inner_conn.pack(padx=15, pady=15)

        tk.Label(inner_conn, text="Serial Port:", font=('Segoe UI', 10),
                 bg=COLORS['card'], fg=COLORS['text']).grid(row=0, column=0, sticky='w', padx=5)

        self.port_var = tk.StringVar()
        port_frame = tk.Frame(inner_conn, bg=COLORS['bg'], highlightbackground=COLORS['border'],
                              highlightthickness=1)
        port_frame.grid(row=0, column=1, padx=5)
        self.port_menu = tk.OptionMenu(port_frame, self.port_var, *list_serial_ports())
        self.port_menu.config(bg=COLORS['bg'], fg=COLORS['text'],
                              font=('Segoe UI', 9), relief='flat',
                              activebackground=COLORS['card'],
                              activeforeground=COLORS['text'], bd=0)
        self.port_menu['menu'].config(bg=COLORS['card'], fg=COLORS['text'],
                                      activebackground=COLORS['accent'])
        self.port_menu.pack(padx=5, pady=3)

        refresh_btn = ModernButton(inner_conn, "üîÑ Refresh", self.refresh_ports,
                                   bg_color=COLORS['border'], width=100, height=35)
        refresh_btn.grid(row=0, column=2, padx=5)

        self.connect_btn = ModernButton(inner_conn, "üîå Connect", self.connect_serial,
                                        bg_color=COLORS['success'], width=110, height=35)
        self.connect_btn.grid(row=0, column=3, padx=5)

        self.disconnect_btn = ModernButton(inner_conn, "‚èπ Disconnect", self.disconnect_serial,
                                           bg_color=COLORS['danger'], width=120, height=35)
        self.disconnect_btn.grid(row=0, column=4, padx=5)

        # Info Cards
        cards_frame = tk.Frame(root, bg=COLORS['bg'])
        cards_frame.pack(fill='x', padx=10, pady=10)

        self.temp_card = StatusCard(cards_frame, "Temperature", "üå°Ô∏è")
        self.temp_card.pack(side='left', expand=True, fill='both', padx=(0, 5))

        self.slots_card = StatusCard(cards_frame, "Parking Slots", "üöó")
        self.slots_card.pack(side='left', expand=True, fill='both', padx=5)

        self.status_card = StatusCard(cards_frame, "Status", "üì°")
        self.status_card.pack(side='left', expand=True, fill='both', padx=(5, 0))
        self.status_card.update_value("Offline", COLORS['danger'])

        # Control Panel
        ctrl_frame = tk.Frame(root, bg=COLORS['card'])
        ctrl_frame.pack(fill='x', padx=10, pady=10)

        tk.Label(ctrl_frame, text="Control Panel", font=('Segoe UI', 12, 'bold'),
                 bg=COLORS['card'], fg=COLORS['text']).pack(anchor='w', padx=15, pady=(15, 10))

        btn_container = tk.Frame(ctrl_frame, bg=COLORS['card'])
        btn_container.pack(padx=15, pady=(0, 15))

        ModernButton(btn_container, "üì• Open IN Gate", lambda: self.send_cmd("OPEN_IN"),
                     bg_color=COLORS['success'], width=140, height=45).pack(side='left', padx=5)
        ModernButton(btn_container, "üì§ Open OUT Gate", lambda: self.send_cmd("OPEN_OUT"),
                     bg_color=COLORS['warning'], width=140, height=45).pack(side='left', padx=5)
        ModernButton(btn_container, "üìä Get Status", lambda: self.send_cmd("GET_STATUS"),
                     bg_color=COLORS['accent'], width=130, height=45).pack(side='left', padx=5)

        # Log Panel
        log_frame = tk.Frame(root, bg=COLORS['card'])
        log_frame.pack(fill='both', expand=True, padx=10, pady=(0, 10))

        tk.Label(log_frame, text="System Log", font=('Segoe UI', 12, 'bold'),
                 bg=COLORS['card'], fg=COLORS['text']).pack(anchor='w', padx=15, pady=(15, 5))

        log_container = tk.Frame(log_frame, bg=COLORS['bg'], highlightbackground=COLORS['border'],
                                 highlightthickness=1)
        log_container.pack(fill='both', expand=True, padx=15, pady=(0, 15))

        self.log_box = scrolledtext.ScrolledText(
            log_container, height=10, state='disabled',
            bg=COLORS['bg'], fg=COLORS['text'],
            font=('Consolas', 9), relief='flat',
            insertbackground=COLORS['text']
        )
        self.log_box.pack(fill='both', expand=True, padx=2, pady=2)

        # Serial setup
        self.ser = None
        self.reader = None
        self.queue = queue.Queue()
        self.stop_event = threading.Event()

        self.root.after(100, self.process_serial_queue)
        self.refresh_ports()

    def refresh_ports(self):
        ports = list_serial_ports()
        menu = self.port_menu['menu']
        menu.delete(0, 'end')
        for p in ports:
            menu.add_command(label=p, command=lambda v=p: self.port_var.set(v))
        if ports and ports[0] != "No ports found":
            self.port_var.set(ports[0])
        self.log("üîÑ Refreshed serial ports")

    def connect_serial(self):
        port = self.port_var.get()
        if not port or port == "No ports found":
            messagebox.showwarning("Select Port", "Please select a valid serial port.")
            return
        try:
            self.ser = serial.Serial(port, BAUDRATE, timeout=READ_TIMEOUT)
            self.stop_event.clear()
            self.reader = SerialReader(self.ser, self.queue, self.stop_event)
            self.reader.start()
            self.status_card.update_value("Connected", COLORS['success'])
            self.log(f"‚úÖ Connected to {port} @ {BAUDRATE} baud")
        except Exception as e:
            messagebox.showerror("Connection Error", str(e))
            self.log(f"‚ùå Connection failed: {e}")

    def disconnect_serial(self):
        if self.ser:
            self.stop_event.set()
            time.sleep(0.1)
            try:
                self.ser.close()
            except:
                pass
            self.ser = None
            self.status_card.update_value("Offline", COLORS['danger'])
            self.log("‚èπ Disconnected")

    def send_cmd(self, cmd):
        if not self.ser or not self.ser.is_open:
            messagebox.showwarning("Not Connected", "Please connect to Arduino first.")
            return
        try:
            self.ser.write((cmd + "\n").encode())
            self.log(f"üì§ SENT: {cmd}")
        except Exception as e:
            self.log(f"‚ùå Send error: {e}")

    def process_serial_queue(self):
        while not self.queue.empty():
            line = self.queue.get_nowait()
            self.handle_line(line)
        self.root.after(100, self.process_serial_queue)

    def handle_line(self, line):
        if not line:
            return

        if line.startswith("__ERROR__"):
            self.log(f"‚ö†Ô∏è Serial error: {line}")
            return

        self.log(f"üì• {line}")

        try:
            if line.startswith("STATUS:"):
                part = line[len("STATUS:"):]
                segs = part.split(';')
                data = {}
                for s in segs:
                    if ':' in s:
                        k, v = s.split(':', 1)
                        data[k.strip()] = v.strip()

                temp = data.get("TEMP")
                slots = data.get("SLOTS")

                if temp:
                    self.temp_card.update_value(f"{temp}¬∞C")
                if slots:
                    used, total = slots.split('/')
                    self.slots_card.update_value(slots)
                    if int(used) >= int(total):
                        self.slots_card.value_lbl.config(fg=COLORS['danger'])
                    elif int(used) / int(total) > 0.7:
                        self.slots_card.value_lbl.config(fg=COLORS['warning'])
                    else:
                        self.slots_card.value_lbl.config(fg=COLORS['success'])

            elif line.startswith("RFID:UID:"):
                uid = line[len("RFID:UID:"):].strip()
                self.log(f"üîê RFID detected: {uid}")

        except Exception as e:
            self.log(f"‚ö†Ô∏è Parse error: {e}")

    def log(self, msg):
        timestamp = time.strftime("%H:%M:%S")
        self.log_box.configure(state='normal')
        self.log_box.insert('end', f"[{timestamp}] {msg}\n")
        self.log_box.see('end')
        self.log_box.configure(state='disabled')


if __name__ == "__main__":
    root = tk.Tk()
    app = SmartParkingGUI(root)
    root.geometry("750x800")
    root.minsize(700, 700)
    root.mainloop()
